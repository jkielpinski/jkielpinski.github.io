---
title: Predicting .NET's System.Random (Xoshiro256**) output
author: Jason Kielpinski
date: July 8, 2024
modified: July 8, 2024
keywords: [random number prediction, system.net, system.random, xoshiro, xoshiro256**]
---

## Intro

.NET's [`System.Random`]() class, starting from .NET 6.0, uses the Xoshiro256** algorithm. `System.Random` is not intended to be suitable for generating secrets, and some internet research confirmed that the Xoshiro256** algorithm should be reversible. E.g., given some random outputs from `System.Random`, it should be possible to predict future outputs. However, I could not find a proof of concept for *how* to do this.

This would useful for an attacker if `System.Random` is being used to generate something that is supposed to be unguessable. For example, if an application uses `System.Random` to generate a secret key, an attacker could take one secret key and use it to predict all future secret keys. 

Below is a proof of concept I developed for predicting the next `System.Random` outputs, given previous outputs of `System.Random.NextBytes()`, `NextInt64()`, or `NextDouble()`. Using outputs from `System.Random.Next()` remains elusive for the time being, for reasons I will get into.

## Internal state

Internally, `System.Random` uses four `ulong` state variables (`s0` thru `s3`) to produce a `ulong` random value, which is then manipulated into whatever output format is requested (bytes, integer, etc). Random numbers are generated by the internal [`NextUint64()` method](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Random.Xoshiro256StarStarImpl.cs#L53) with the following logic:

~~~csharp
internal ulong NextUInt64()
{
    ulong s0 = _s0, s1 = _s1, s2 = _s2, s3 = _s3;

    ulong result = BitOperations.RotateLeft(s1 * 5, 7) * 9;
    ulong t = s1 << 17;

    s2 ^= s0;
    s3 ^= s1;
    s1 ^= s2;
    s0 ^= s3;

    s2 ^= t;
    s3 = BitOperations.RotateLeft(s3, 45);

    _s0 = s0;
    _s1 = s1;
    _s2 = s2;
    _s3 = s3;

    return result;
}
~~~

From this code snippet we can gather some facts. The state variables change with every invocation, so we have to keep track of which invocation we're referring to. $s_1^n$ refers to `_s1` after $n$ invocations of the RNG. We can say:

* **Fact 1**: $f(n) = RL(5 \cdot s_1^n \pmod {2^{64}}, 7) \cdot 9 \pmod {2^{64}}$

	This is the random number generated, called `result` in the code. Note: the $\pmod {2^{64}}$ here is because we are working with `ulong`s -- any time you multiply or add them, they can overflow. `ulong`s have a max value of $2^{64}$; values past that will wrap around.

* **Fact 2**: $s_0^{n+1} = s_0^n \oplus s_3^n \oplus s_1^n$
* **Fact 3**: $s_1^{n+1} = s_1^n \oplus s_2^n \oplus s_0^n$
* **Fact 4**: $s_2^{n+1} = s_2^n \oplus s_0^n \oplus (s_1^n \gg 17)$
* **Fact 5**: $s_3^{n+1} = RL(s_3^n \oplus s_1^n, 45)$


We know the output of the RNG, $f(n)$, and need to solve for the state variables, $s_0, ..., s_3$. Once we have those, we can predict future outputs by just running the algorithm ourselves.

## Solving for state variables

### $s_1$

At this point we know only $f(n)$ (the random output), not any of the state variables yet. Take **fact 1** above:

$f(n) = RL(5 \cdot s_1^n \pmod {2^{64}}, 7) \cdot 9 \pmod {2^{64}}$

And solve for $s_1^n$. Note that, because we are working in modular arithmetic, we multiply by the multiplicative modular inverses $5^{-1} \pmod {2^{64}}$ and $9^{-1} \pmod {2^{64}}$ instead of dividing.

* $\Rightarrow f(n) \cdot (9^{-1} \pmod {2^{64}}) = RL(s_1^n \cdot 5, 7)$
* $\Rightarrow RR(f(n) \cdot (9^{-1} \pmod {2^{64}}), 7) = s_1^n \cdot 5$
* $\Rightarrow s_1^n = RR(f(n) \cdot (9^{-1} \pmod {2^{64}}, 7) \cdot (5^{-1} \pmod {2^{64}}$)

These modular inverses can be calculated, e.g. with Wolfram Alpha: $5^{-1} \pmod {2^{64}} =$ [14757395258967641293](https://www.wolframalpha.com/input?i=5%5E-1+mod+2%5E64) and $9^{-1} \pmod {2^{64}} =$ [10248191152060862009](https://www.wolframalpha.com/input?i=9%5E-1+mod+2%5E64)


### $s_2$

Now we know $f(n)$ and $s_1^n$ so first take **fact 3** and rearrange so we know everything on the left side:

* $s_1^{n+1} = s_1^n \oplus s_2^n \oplus s_0^n$
* $\Rightarrow s_1^{n+1} \oplus s_1^n = s_2^n \oplus s_0^n$

Note the right hand term is a part of **fact 4**. If we substitute the left hand side for that part of fact 4, we can solve for $s_2^{n+1}$:

$s_2^{n+1} = s_1^{n+1} \oplus s_1^n \oplus (s_1^n \gg 17)$

### $s_0$

We know $f(n)$, $s_1^n$ and $s_2^n$. Take **fact 3** again and solve for $s_0^n$:

* $s_1^{n+1} = s_1^n \oplus s_2^n \oplus s_0^n$
* $\Rightarrow s_0^n = s_1^n \oplus s_2^n \oplus s_1^{n+1}$

### $s_3$

Finally, we know $f(n)$, $s_0^n$, $s_1^n$ and $s_2^n$. Use **fact 2** to find $s_3^n$:

* $s_0^{n+1} = s_0^n \oplus s_3^n \oplus s_1^n$
* $\Rightarrow s_3^n  = s_0^n \oplus s_1^n \oplus s_0^{n+1}$


## Putting it together

The code below uses these values to assemble a full set of state variables for $n = 1$: `s0_1`, `s1_1`, `s2_1`, `s3_1`

~~~csharp
static ulong S1(ulong randomValue) =>
	BitOperations.RotateRight(randomValue * 10248191152060862009, 7) * 14757395258967641293;

static ulong S2(ulong s1_1, ulong s1_0) =>
	s1_1 ^ s1_0 ^ (s1_0 << 17);

static ulong S0(ulong s1_0, ulong s2_0, ulong s1_1) =>
	s1_1 ^ s1_0 ^ s2_0;

static ulong S3(ulong s0_0, ulong s1_0, ulong s0_1) =>
	s0_0 ^ s0_1 ^ s1_0;

void DetermineStateFromRandomUlongs(ulong r0, ulong r1, ulong r2, ulong r3)
{
	var s1_0 = S1(r0);

	var s1_1 = S1(r1);
	var s2_1 = S2(s1_1, s1_0);

	var s1_2 = S1(r2);
	var s2_2 = S2(s1_2, s1_1);
	var s0_1 = S0(s1_1, s2_1, s1_2);

	var s1_3 = S1(r3);
	var s0_2 = S0(s1_2, s2_2, s1_3);
	var s3_1 = S3(s0_1, s1_1, s0_2);

	_s0 = s0_1;
	_s1 = s1_1;
	_s2 = s2_1;
	_s3 = s3_1;
}
~~~

From here we can advance the state 3 times to catch up with the RNG state. Then we can just copy over the logic from `System.Random` internals to generate new random numbers that should match the next outputs of the `System.Random` instance whose state we determined, predicting the next values.

Just one obstacle...

## External outputs

`System.Random` *internally* uses `ulong`. But *external* output is `int`, `byte[]`, `double`, `long`, `float` -- *not* `ulong`. So how can we take one of these external outputs, convert it to an internal output (`ulong`), and then calculate the state?


### Random.NextBytes()

The simplest case is for `byte[]` output. Just take the first four `ulong`s worth of bytes (32 bytes), parse each one as a `ulong`, and use that as the input. Then increment the RNG for any additional data in there, to catch up the state. E.g.

~~~csharp
randombytes = [
	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, //=r0
	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, //=r1
	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, //=r2
	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, //=r3
	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, //increment rng
	0xaa, 0xaa, 0xaa //increment rng again
]
~~~


### Random.NextInt64()

The next simplest case is for `long`. The logic for generating a `long` (essentially) looks like this (minus a few edge cases):

~~~csharp
public override long NextInt64()
{
	return NextUInt64() >> 1;
}
~~~

It right shifts by 1, chopping off 1 bit of information about the original `ulong` random value. So the bits that we know look like:

~~~csharp
r0 = 0 1 0 ... 0 ?
r1 = 1 1 0 ... 1 ?
r2 = 0 0 0 ... 0 ?
r3 = 0 1 1 ... 0 ?
~~~

Each random value has one mystery bit at the end. There's 16 possible permutations for the unknown values. The last bits could be: `[0 0 0 0], [0 0 0 1], [0 0 1 0], [0 0 1 1], [0 1 0 0], [0 1 0 1], [0 1 1 0], [0 1 1 1], [1 0 0 0], [1 0 0 1], [1 0 1 0], [1 0 1 1], [1 1 0 0], [1 1 0 1], [1 1 1 0], [1 1 1 1]`

So we can just brute force it. Determine the state value for each permutation, then predict some random numbers and check if they match up with the provided random numbers. This takes a fraction of a second and works well.

### Random.NextDouble()

The logic for generating a `double` looks like this:

~~~csharp
public override double NextDouble() =>
    (NextUInt64() >> 11) * (1.0 / (1ul << 53));
~~~

It chops off 11 bits this time, and does some calculations. We can undo the calculations:

~~~csharp
var r = ((ulong)randomValue * (1ul << 53)) << 11;
~~~

Then... brute force the 11 bits again? With multithreading and optimization, my laptop could brute force 11 bits in an estimated 2.75 days. This could be doable in an assessment. Afterwards, you'd need to have the application generate another random number, and increment your state (e.g. generate random numbers) until the predicted output matched the one generated by the application.

### Random.Next()

The logic for generating `int`s looks like:

~~~csharp
public override int Next()
{
	return NextUInt64() >> 33;
}
~~~

33 bits this time.. 5444517870735015415413993718908291383296 possible permutations. I tried it and it was going to take 3.5 trillion years with the brute force approach. Sadly, I don't have a solution for determining the state given random `int`s yet. Going to stew on that.


